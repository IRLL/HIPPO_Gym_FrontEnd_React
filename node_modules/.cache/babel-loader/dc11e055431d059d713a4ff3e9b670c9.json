{"ast":null,"code":"'use strict'; // Maps for number <-> hex string conversion\n\nvar _byteToHex = [];\nvar _hexToByte = {};\n\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n} // **`parse()` - Parse a UUID into it's component bytes**\n\n\nfunction parse(s, buf, offset) {\n  var i = buf && offset || 0;\n  var ii = 0;\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function (oct) {\n    if (ii < 16) {\n      // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  }); // Zero out remaining bytes if string was short\n\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n} // **`unparse()` - Convert UUID byte array (ala parse()) into a string**\n\n\nfunction unparse(buf, offset) {\n  var i = offset || 0;\n  var bth = _byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + '-' + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = {\n  parse: parse,\n  unparse: unparse\n};","map":{"version":3,"sources":["/Charlie/Dropbox/Development/IRLL/hippoGym/Front/node_modules/uuid-parse/uuid-parse.js"],"names":["_byteToHex","_hexToByte","i","toString","substr","parse","s","buf","offset","ii","toLowerCase","replace","oct","unparse","bth","module","exports"],"mappings":"AAAA,a,CAEA;;AACA,IAAIA,UAAU,GAAG,EAAjB;AACA,IAAIC,UAAU,GAAG,EAAjB;;AACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,GAApB,EAAyBA,CAAC,EAA1B,EAA8B;AAC5BF,EAAAA,UAAU,CAACE,CAAD,CAAV,GAAgB,CAACA,CAAC,GAAG,KAAL,EAAYC,QAAZ,CAAqB,EAArB,EAAyBC,MAAzB,CAAgC,CAAhC,CAAhB;AACAH,EAAAA,UAAU,CAACD,UAAU,CAACE,CAAD,CAAX,CAAV,GAA4BA,CAA5B;AACD,C,CAED;;;AACA,SAASG,KAAT,CAAeC,CAAf,EAAkBC,GAAlB,EAAuBC,MAAvB,EAA+B;AAC7B,MAAIN,CAAC,GAAIK,GAAG,IAAIC,MAAR,IAAmB,CAA3B;AACA,MAAIC,EAAE,GAAG,CAAT;AAEAF,EAAAA,GAAG,GAAGA,GAAG,IAAI,EAAb;AACAD,EAAAA,CAAC,CAACI,WAAF,GAAgBC,OAAhB,CAAwB,cAAxB,EAAwC,UAASC,GAAT,EAAc;AACpD,QAAIH,EAAE,GAAG,EAAT,EAAa;AAAE;AACbF,MAAAA,GAAG,CAACL,CAAC,GAAGO,EAAE,EAAP,CAAH,GAAgBR,UAAU,CAACW,GAAD,CAA1B;AACD;AACF,GAJD,EAL6B,CAW7B;;AACA,SAAOH,EAAE,GAAG,EAAZ,EAAgB;AACdF,IAAAA,GAAG,CAACL,CAAC,GAAGO,EAAE,EAAP,CAAH,GAAgB,CAAhB;AACD;;AAED,SAAOF,GAAP;AACD,C,CAED;;;AACA,SAASM,OAAT,CAAiBN,GAAjB,EAAsBC,MAAtB,EAA8B;AAC5B,MAAIN,CAAC,GAAGM,MAAM,IAAI,CAAlB;AACA,MAAIM,GAAG,GAAGd,UAAV;AACA,SAAQc,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CAAH,GAAgBY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CAAnB,GACAY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CADH,GACgBY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CADnB,GACgC,GADhC,GAEAY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CAFH,GAEgBY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CAFnB,GAEgC,GAFhC,GAGAY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CAHH,GAGgBY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CAHnB,GAGgC,GAHhC,GAIAY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CAJH,GAIgBY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CAJnB,GAIgC,GAJhC,GAKAY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CALH,GAKgBY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CALnB,GAMAY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CANH,GAMgBY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CANnB,GAOAY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CAPH,GAOgBY,GAAG,CAACP,GAAG,CAACL,CAAC,EAAF,CAAJ,CAP3B;AAQD;;AAEDa,MAAM,CAACC,OAAP,GAAiB;AACfX,EAAAA,KAAK,EAAEA,KADQ;AAEfQ,EAAAA,OAAO,EAAEA;AAFM,CAAjB","sourcesContent":["'use strict';\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; i++) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\n// **`parse()` - Parse a UUID into it's component bytes**\nfunction parse(s, buf, offset) {\n  var i = (buf && offset) || 0;\n  var ii = 0;\n\n  buf = buf || [];\n  s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {\n    if (ii < 16) { // Don't overflow!\n      buf[i + ii++] = _hexToByte[oct];\n    }\n  });\n\n  // Zero out remaining bytes if string was short\n  while (ii < 16) {\n    buf[i + ii++] = 0;\n  }\n\n  return buf;\n}\n\n// **`unparse()` - Convert UUID byte array (ala parse()) into a string**\nfunction unparse(buf, offset) {\n  var i = offset || 0;\n  var bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = {\n  parse: parse,\n  unparse: unparse\n};\n"]},"metadata":{},"sourceType":"script"}